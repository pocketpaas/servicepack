#!/usr/bin/perl

use strict;
use warnings;

use File::Temp qw(tempdir);
use Cwd;
use Getopt::Long qw(GetOptionsFromArray);

our $VERSION = '0.1';

my $OS_MAP = {
    'ubuntu/13.04' => 'lopter/raring-base:latest',
    'ubuntu/12.10' => 'ubuntu:12.10',
};

my %opts;

my $commands = {
    'build' => sub {
        my $argv = shift;

        GetOptionsFromArray( $argv, \%opts, 'build-dir|b=s', 'tag|t=s' );

        my $dir_to_build = $opts{'build-dir'};
        my $tag          = $opts{'tag'};

        $tag ||= 'latest';

        my $query_script = "$dir_to_build/bin/query";

        -e $query_script || die "Unable to find query script.";

        my $os = `$query_script os`;
        chomp($os);
        $os || die "OS not defined.\n";
        my $docker_base = $OS_MAP->{$os}
            || die "No docker image for OS $os.\n";

        my $build_dir = tempdir( CLEANUP => 1 );

        system("tar -C $dir_to_build/ -cvf - . | tar -C $build_dir -xf -");

        # TODO make this dockerfile not ubuntu specific
        open my $dockerfile, ">", "$build_dir/Dockerfile";
        print $dockerfile <<BUILD;
from $docker_base
run     apt-get update
run     DEBIAN_FRONTEND=noninteractive apt-get install openssh-server supervisor -y
run     mkdir -p /var/run/sshd
run     mkdir -p /var/log/supervisor
run     locale-gen en_US en_US.UTF-8
add     supervisord.conf /etc/supervisor/conf.d/supervisord.conf
run     /bin/sh -c 'echo root:testpass | chpasswd'
add     . /service
run     /service/bin/build base
expose  22
cmd     ["/usr/bin/supervisord", "-n"]
BUILD
        close $dockerfile;

        open my $supervisor, ">", "$build_dir/supervisord.conf";
        print $supervisor <<SUPERVISOR;
[supervisord]
nodaemon=true

[program:sshd]
command=/usr/sbin/sshd -D
stdout_logfile=/var/log/supervisor/%(program_name)s.log
stderr_logfile=/var/log/supervisor/%(program_name)s.log
autorestart=true

[program:mongod]
command=/service/bin/run
stdout_logfile=/var/log/supervisor/%(program_name)s.log
stderr_logfile=/var/log/supervisor/%(program_name)s.log
autorestart=true
SUPERVISOR
        close $supervisor;

        DEBUG("docker build dir: $build_dir");

        my $previous_dir = getcwd;
        chdir $build_dir;
        system("docker build -t $tag .");
        chdir $previous_dir;
    },
    'setup' => sub {
        my $argv = shift;

        GetOptionsFromArray( $argv, \%opts, 'build-dir|b=s', 'tag|t=s',
            'image|i=s' );

        my $dir_to_build = $opts{'build-dir'};
        my $image        = $opts{'image'};
        my $tag          = $opts{'tag'};

        #my $build_dir = tempdir( CLEANUP => 1 );
        my $build_dir = tempdir();

        # TODO generate secrets
        my $ENV_VARS = '';

        open my $dockerfile, ">", "$build_dir/Dockerfile";
        print $dockerfile <<BUILD;
from $image
env     MYSQL_ROOT_PASSWORD foobar
run     /service/bin/build setup
expose  22
cmd     ["/usr/bin/supervisord", "-n"]
BUILD
        close $dockerfile;

        DEBUG("docker build dir: $build_dir");

        my $previous_dir = getcwd;
        chdir $build_dir;
        system("docker build -t $tag .");
        chdir $previous_dir;
    },
    'help' => sub {
        my $argv = shift;

        my $command = shift @$argv;

        if ($command) {
            my %options = (
                -verbose    => 99,
                -exitstatus => 0,
                -sections   => uc($command),
            );

            pod2usage(%options);
        }
        else {
            pod2usage(2);
        }
    },
};

run_svp(@ARGV) unless defined caller;

sub run_svp {
    my (@argv) = @_;

    # set options to nothing so that running multiple times in tests
    # does not reuse options
    %opts = ();

    my $command;

    if ( scalar(@argv) == 0 || $argv[0] =~ /^-/ ) {

        # check to make sure there's not a subcommand later in the arg list
        if ( grep { exists $commands->{$_} } @argv ) {
            ERROR("The command should be first.");
            exit(-2);
        }
        $command = 'help';
    }
    else {
        $command = $argv[0];
    }

    if ( exists $commands->{$command} ) {

        # parse global options first
        Getopt::Long::Configure('pass_through');
        GetOptionsFromArray(
            \@argv,    \%opts, 'verbose', 'quiet',
            'dry-run', 'help', 'version'
        );
        Getopt::Long::Configure('no_pass_through');
    }

    if ( exists $commands->{$command} ) {
        if ( $opts{'help'} ) {
            $commands->{'help'}->( [$command] );
        }
        elsif ( $opts{'version'} ) {
            show_version();
        }
        else {
            shift(@argv);    # remove the command from the array
            $commands->{$command}->( \@argv );
        }
    }
    else {

        ERROR("Unknown command $command.");
        exit(-2);
    }
}

sub show_version {
    print "svp version $VERSION\n";
}

# a few log4perl-alikes
sub ERROR {
    printf "ERROR: %s\n", shift;
}

sub WARN {
    printf "WARN: %s\n", shift;
}

sub INFO {
    printf "INFO: %s\n", shift if !$opts{quiet};
}

sub DEBUG {
    printf "DEBUG: %s\n", shift if $opts{verbose};
}

