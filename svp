#!/usr/bin/perl

use strict;
use warnings;

use File::Temp qw(tempdir);
use Cwd;
use Getopt::Long qw(GetOptionsFromArray);
use File::Copy;
use File::Path qw(mkpath);

our $VERSION = '0.1';

my $OS_MAP = {
    'ubuntu/13.04' => 'lopter/raring-base:latest',
    'ubuntu/12.10' => 'ubuntu:12.10',
};

my %opts;

my $commands = {
    'build' => sub {
        my $argv = shift;

        GetOptionsFromArray( $argv, \%opts, 'build-dir|b=s', 'tag|t=s' );

        my $dir_to_build = $opts{'build-dir'}
            || die "Specify build dir with --build-dir or -b.\n";
        my $tag = $opts{'tag'}
            || die "Specify tag with --tag or -t.\n";

        $tag ||= 'latest';

        my $query_script = "$dir_to_build/bin/query";

        -e $query_script || die "Unable to find query script.";

        my $os = `$query_script os`;
        chomp($os);
        $os || die "OS not defined.\n";
        my $docker_base = $OS_MAP->{$os}
            || die "No docker image for OS $os.\n";

        my $build_dir = tempdir( CLEANUP => 1 );

        system("tar -C $dir_to_build/ -cvf - . | tar -C $build_dir -xf -");

        # TODO make this dockerfile not ubuntu specific
        open my $dockerfile, ">", "$build_dir/Dockerfile";
        print $dockerfile <<BUILD;
from $docker_base
run     apt-get update

# setup sshd and supervisor
run     DEBIAN_FRONTEND=noninteractive apt-get install openssh-server supervisor -y
run     mkdir -p /var/run/sshd
run     mkdir -p /var/log/supervisor
run     locale-gen en_US en_US.UTF-8
add     supervisord.conf /etc/supervisor/conf.d/supervisord.conf

# configure keyed ssh access
run     mkdir -p /root/.ssh
run     chmod 600 /root/.ssh
add     authorized_keys /root/.ssh/authorized_keys
run     chmod 600 /root/.ssh/authorized_keys
run     chown root.root /root/.ssh/authorized_keys

# add service scripts and build
add     . /service
run     /service/bin/build base
expose  22
cmd     ["/usr/bin/supervisord", "-n"]
BUILD
        close $dockerfile;

        if ( $opts{'ssh-pubkey-file'} ) {
            copy( $opts{'ssh-pubkey-file'}, "$build_dir/authorized_keys" );
        }
        else {
            copy( generate_ssh_key(), "$build_dir/authorized_keys" );
        }

        open my $supervisor, ">", "$build_dir/supervisord.conf";
        print $supervisor <<SUPERVISOR;
[supervisord]
nodaemon=true

[program:sshd]
command=/usr/sbin/sshd -D
stdout_logfile=/var/log/supervisor/%(program_name)s.log
stderr_logfile=/var/log/supervisor/%(program_name)s.log
autorestart=true

[program:service]
command=/service/bin/run
stdout_logfile=/var/log/supervisor/%(program_name)s.log
stderr_logfile=/var/log/supervisor/%(program_name)s.log
autorestart=true
SUPERVISOR
        close $supervisor;

        DEBUG("docker build dir: $build_dir");

        my $previous_dir = getcwd;
        chdir $build_dir;
        system("docker build -t $tag .");
        chdir $previous_dir;
    },
    'setup' => sub {
        my $argv = shift;

        GetOptionsFromArray( $argv, \%opts, 'build-dir|b=s', 'tag|t=s',
            'image|i=s' );

        my $dir_to_build = $opts{'build-dir'};
        my $image        = $opts{'image'};
        my $tag          = $opts{'tag'};

        #my $build_dir = tempdir( CLEANUP => 1 );
        my $build_dir = tempdir();

        # generate secrets
        my $SECRET_VARS = '';

        my $query_script = "$dir_to_build/bin/query";
        -e $query_script || die "Unable to find query script.";

        my $secret_names = `$query_script secrets`;
        chomp($secret_names);

        if ($secret_names) {
            foreach my $secret ( split( /\n/, $secret_names ) ) {
                $SECRET_VARS .= "env $secret " . generate_secret();
            }
        }

        system("tar -C $dir_to_build/ -cvf - . | tar -C $build_dir -xf -");

        open my $dockerfile, ">", "$build_dir/Dockerfile";
        print $dockerfile <<BUILD;
from $image
add     . /service
$SECRET_VARS
run     /service/bin/build setup
expose  22
cmd     ["/usr/bin/supervisord", "-n"]
BUILD
        close $dockerfile;

        DEBUG("docker build dir: $build_dir");

        my $previous_dir = getcwd;
        chdir $build_dir;
        system("docker build -t $tag .");
        chdir $previous_dir;
    },
    'client' => sub {
        my $argv = shift;

        GetOptionsFromArray( $argv, \%opts, 'container|c=s' );

        my $container = $opts{'container'}
            || die "Specify container with --container or -c.\n";

        run_in_container( $container, '/service/bin/client' );
    },
    'shell' => sub {
        my $argv = shift;

        GetOptionsFromArray( $argv, \%opts, 'container|c=s' );

        my $container = $opts{'container'}
            || die "Specify container with --container or -c.\n";

        run_in_container($container);
    },
    'help' => sub {
        my $argv = shift;

        my $command = shift @$argv;

        if ($command) {
            my %options = (
                -verbose    => 99,
                -exitstatus => 0,
                -sections   => uc($command),
            );

            pod2usage(%options);
        }
        else {
            pod2usage(2);
        }
    },
};

run_svp(@ARGV) unless defined caller;

sub run_svp {
    my (@argv) = @_;

    # set options to nothing so that running multiple times in tests
    # does not reuse options
    %opts = ();

    my $command;

    if ( scalar(@argv) == 0 || $argv[0] =~ /^-/ ) {

        # check to make sure there's not a subcommand later in the arg list
        if ( grep { exists $commands->{$_} } @argv ) {
            ERROR("The command should be first.");
            exit(-2);
        }
        $command = 'help';
    }
    else {
        $command = $argv[0];
    }

    if ( exists $commands->{$command} ) {

        # parse global options first
        Getopt::Long::Configure('pass_through');
        GetOptionsFromArray( \@argv, \%opts, 'verbose', 'quiet',
            'dry-run', 'help', 'version', 'ssh-pubkey-file|s=s' );
        Getopt::Long::Configure('no_pass_through');
    }

    if ( exists $commands->{$command} ) {
        if ( $opts{'help'} ) {
            $commands->{'help'}->( [$command] );
        }
        elsif ( $opts{'version'} ) {
            show_version();
        }
        else {
            shift(@argv);    # remove the command from the array
            $commands->{$command}->( \@argv );
        }
    }
    else {

        ERROR("Unknown command $command.");
        exit(-2);
    }
}

sub show_version {
    print "svp version $VERSION\n";
}

sub generate_ssh_key {
    my $svp_key_dir  = "$ENV{HOME}/.servicepack/key";
    my $svp_key_path = "$svp_key_dir/id_rsa";

    if ( !-e $svp_key_path ) {
        mkpath($svp_key_dir);
        INFO("Generating SSH key for container access.");
        system("ssh-keygen -t rsa -N '' -f $svp_key_path");
    }

    return "$svp_key_path.pub";
}

# TODO use a real random seed like Math::TrulyRandom to seed the generator
sub generate_secret {

    my @chars = ( 'a' .. 'z', 'A' .. 'Z', '0' .. '9' );

    my $secret;
    $secret .= $chars[ rand( scalar(@chars) ) ] for 1 .. 12;

    return $secret;
}

sub run_in_container {
    my ( $container_id, @command_and_args ) = @_;

    my $port = `docker port $container_id 22`;
    chomp($port);

    exec(
        qw(ssh -t -i),      "$ENV{HOME}/.servicepack/key/id_rsa",
        '-o',               'UserKnownHostsFile /dev/null',
        '-o',               'StrictHostKeyChecking no',
        '-p',               $port,
        qw(root@localhost), @command_and_args
    );
}

# a few log4perl-alikes
sub ERROR {
    printf "ERROR: %s\n", shift;
}

sub WARN {
    printf "WARN: %s\n", shift;
}

sub INFO {
    printf "INFO: %s\n", shift if !$opts{quiet};
}

sub DEBUG {
    printf "DEBUG: %s\n", shift if $opts{verbose};
}

